Python code is hard to sandbox because Python is created around giving a lot of flexibility to the programmers, like in how it doesn't allow for explicit typing and have things like dynamically growing array that can contain any arbitrary item, etc. In these cases it's harder to properly enforce and validate security checks on Python code, as it also requires the compiler needing to have a high-level understanding of what the Python code is doing. Also since Python is written using C (and thus is less performant) any additional checks we add can also significantly increase the runtime.

C code is hard to sandbox properly because the C standard allows for too broad access and interactions with hardware like weird memory accesses (e.g. allowing indexing one past/before the allocated chunk) or unsafe operations and the language inherently has very little memory bound or buffer overflow checking. If we want to properly sandbox C we will likely to follow the ideals of Firecracker and limit ourselves to a subset of C that we can properly validate and add checks for.

While machine code is most like WebAssembly (and vice versa), and it is also properly the language out of the three alternatives that will can be best sandboxed while maintaining high performance (given its low-level nature), machine code is still difficult to sandbox because it still inherently allows constructs like jumping to an arbitrary address location and lack certain high-level constructs in its language that will make it easier for us to check whether a program is accessing a resource or a memory location that it shouldn't be able to.